
## 进程的概念，组成，特征

- 程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合
- 进程：是动态的，是程序的一次执行过程
	- 定义: 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
	- 组成
		- PCB(是进程存在的唯一标志)
			- 进程描述信息
			- 进程控制和管理信息
			- 资源分配清单
			- 处理机相关信息
		- 程序段
			- 程序的代码（指令序列）
		- 数据段
			- 运行过程中产生的各种数据（如：程序中定义的变量）
	- 特征
		- 动态性：进程是程序的一次执行过程,是动态地产生,变化和消亡的
		- 并发性：内存中有多个进程实体,各进程可并发执行
		- 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位
		- 异步性：各进程按各自独立的、不可预知的速度向前推进,操作系统要提供“进程同步机制”来解决异步问题
		- 结构性：每个进程都会配置一个PCB。结构上看,进程由程序段、数据段、PCB组成

## 进程的状态与转换

- 状态
	- 运行状态 - 占有CPU，并在CPU上运行
	- 就绪状态 - 已经具备运行条件,但由于没有空闲CPU，而暂时不能运行
	- 阻塞状态 - 因等待某一事件而暂时不能运行
	- 创建状态 - 进程正在被创建,操作系统为进程分配资源，初始化PCB
	- 终止状态 - 进程正在从系统中被撤销，操作系统回回收进程拥有的资源，撤销PCB
- 状态间的转化
	- 就绪态->运行态 - 进程被调度
	- 运行态->就绪态 - 时间片到,或CPU被其他高优先级的进程抢占
	- 运行态->阻塞态 - 等待系统资源分配,或等待某事件发生(主动行为)
	- 阻塞态->就绪态 - 资源分配到位,等待的事件发生(被动行为)
	- 创建态->就绪态 - 系统完成创建进程相关的工作
	- 运行态->终止态 - 进程运行结束,或运行过程中遇到不可修复的错误
	- ![[Pasted image 20240620142213.png]]
- 进程的组织方式(各个进程PCB的组织方式)
	- 链式方式
		- 按照进程状态将PCB分为多个队列
		- 操作系统持有指向各个队列的指针
	- 索引方式
		- 根据进程状态的不同,建立几张索引表
		- 操作系统持有指向各个索引表的指针
## 进程控制

- 进程控制
	- 进程控制的主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程、撤销已有进程、实现进程状态转换等功能。
	- 进程控制用原语实现
		- 原语用关/开中断来实现
		- 原语是一种特殊的程序
		- 原语的执行必须一气呵成，不可中断
	- 相关原语
		- 进程的创建
		- 进程的终止
		- 进程的阻塞
		- 进程的唤醒
		- 进程的切换
	- 更新PCB中的信息(修改进程状态(state),保存/恢复运行环境)
	- 将PCB插入合适的队列
	- 分配/回收资源
## 进程通信

- 共享存储
	- 在Linux中,如何实现共享内存
	``` 
	int shm_open(...); //通过 shm_open 系统调用，申请一片共享内存区
	void *mmap (...); //通过mmap系统调用，将共享内存区映射到进程自己的地址空间
	```
- 基于数据结构的共享
		- 基于数据结构的共享:比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多,是一种低级通信方式
	- 基于存储区的共享
		- 基于存储区的共享:操作系统在内存中划出一块共享存储区,数据的形式、存放位置都由通信进程控制,而不是操作系统。这种共享方式速度很快,是一种高级通信方式。
- 消息传递
	- 传递结构化的消息(消息头/消息体)
	- 系统提供“发送/接受原语”
	- 直接通信方式
		- 消息直接挂到接收进程的消息队列里
	- 间接通信方式
		- 消息先发到中间体(信箱)
- 管道通信 
	- 管道只能采用半双工通信,某一时间段内只能实现单向的传输。如果要实现双向同时通信,需要设置两个管道。
	- 各进程要互斥地访问管道(由操作系统实现)
	- 当管道写满时,写进程将阻塞,直到读进程将管道中的数据取走,即可唤醒写进程。
	- 当管道读空时,读进程将阻塞,直到写进程往管道中写入数据,即可唤醒读进程。
	- 管道中的数据一旦被读出,就彻底消失。因此,当多个进程读同一个管道时,可能会错乱。对此,通常有两种解决方案:1一个管道允许多个写进程,一个读进程(2014年408真题高教社官方答案);2允许有多个写进程,多个读进程,但系统会让各个读进程轮流从管道中读数据(Linux的方案)。
## 线程

-  线程：是一个基本的CPU执行单元，也是程序执行流的最小单位
- ![[Pasted image 20240620160520.png]]
- 线程的属性
	- 线程是处理机调度的单位
	- 多CPU计算机中,各个线程可占用不同的CPU
	- 每个线程都有一个线程ID、线程控制块(TCB)
	- 线程也有就绪、阻塞、运行三种基本状态
	- 线程几乎不拥有系统资源
	- 同一进程的不同线程间共享进程的资源
	- 由于共享内存地址空间,同一进程中的线程间通信甚至无需系统干预
	- 同一进程中的线程切换,不会引起进程切换
	- 不同进程中的线程切换,会引起进程切换
	- 切换同进程内的线程,系统开销很小
	- 切换进程,系统开销较大
## 线程的实现方式与多线程模型

- 线程的实现方式
	- 用户级模型
		- 优点:用户级线程的切换在用户空间即可完成,不需要切换到核心态,线程管理的系统开销小,效率高
		- 缺点:当一个用户级线程被阻塞后,整个进程都会被阻塞,并发度不高。多个线程不可在多核处理机上并行运行。
	- 内核级模型
		- 优点:当一个线程被阻塞后,别的线程还可以继续执行,并发能力强。多线程可在多核处理机上并行执行。
		- 缺点:一个用户进程会占用多个内核级线程,线程切换由操作系统内核完成,需要切换到核心态,因此线程管理的成本高,开销大。
- 多线程模型
	- 一对一模型
	- 多对一模型
	- 多对多模型
## 线程的状态与转换

- 与进程相同

## 线程的组织与控制

- ![[Pasted image 20240620162910.png]]

## 处理机调度的概念,层次

- 基本概念
	- 当有一堆任务要处理,但由于资源有限,这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序,这就是“调度”研究的问题。
-  三个层次
	- 高级调度(作业调度)
		- 高级调度(作业调度)。按一定的原则从外存的作业后备队列中挑选一个作业调入内存,并创建进程。每个作业只调入一次,调出一次。作业调入时会建立PCB，调出时才撤销PCB。
	- 中级调度(内存调度)
		- 按照某种策略决定将哪个处于挂起状态的进程重新调入内存。
	- 低级调度(进程调度)
		- 进程调度是操作系统中最基本的一种调度,在一般的操作系统中都必须配置进程调度。
		- 进程调度的频率很高,一般几十毫秒一次。
- 三层调度的联系,对比 
	- ![[Pasted image 20240620164627.png]]
- 进程的“挂起态"
- 七状态模型

## 进程调度的时机，切换的过程，方式

 - 时机
	 - 什么时候需要进程调度?
	 - ![[Pasted image 20240620165126.png]]
	 - 什么时候不能进行进程调度?
		 - 在处理中断的过程中。中断处理过程复杂,与硬件密切相关,很难做到在中断处理过程中进行进程切换。
		 - 中区界临序程核内统系作操在程进
		 - 在原子操作过程中(原语)。原子操作不可中断,要一气呵成(如之前讲过的修改PCB中进程状态标志,并把PCB放到相应队列)
-  切换与过程
	- “狭义的调度”与“切换”的区别
		- 狭义的进程调度指的是从就绪队列中选择一个要运行的进程
		- 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程
		- 广义的进程调度包含了选择一个进程和进程切换两个步骤
	- 进程切换的过程需要做什么?
		- 对原来运行进程各种数据的保存
		- 对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息,这些信息一般保存在进程控制块)
	- 注意:进程切换是有代价的,因此如果过于频繁的进行进程调度、切换,必然会使整个系统的效率降低,使系统大部分时间都花在了进程切换上,而真正用于执行进程的时间减少。
- 方式
	- 非剥夺调度方式(非抢占式)
		- 非剥夺调度方式,又称非抢占方式。即,只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达,当前进程依然会继续使用处理机,直到该进程终止或主动要求进入阻塞态。(实现简单,系统开销小但是无法及时处理紧急任务,适合于早期的批处理系统)
	- 剥夺调度方式(抢占式) 
		-  剥夺调度方式,又称抢占方式。当一个进程正在处理机上执行时,如果有一个更重要或更紧迫的进程需要使用处理机,则立即暂停正在执行的进程,将处理机分配给更重要紧迫的那个进程。(可以优先处理更紧急的进程,也可实现让各进程按时间片轮流执行的功能(通过时钟中断)。适合于分时操作系统、实时操作系统)

## 调度器和闲逛进程

- 调度器
	- 非抢占式调度策略,只有运行进程阻塞或退出才触发调度程序工作
	- 抢占式调度策略,每个时钟中断或k个时钟中断会触发调度程序工作
- 闲逛进程
	- 优先级最低
	- 可以是0地址指令,占一个完整的指令周期(指令周期末尾例行检查中断)
	- 能耗低
## 调度算法的评价指标

- CPU利用率：指CPU”忙碌“的时间占总时间的比例
	- $$ 利用率= \frac {忙碌的时间}{总时间} $$
- 系统吞吐量：单位时间内完成的作业数量
	- $$ 系统吞吐量 = \frac {总共完成了多少道作业}{总共花了多少时间}  $$
- 周转时间：指从作业被提交交给系统开始，到作业完成为止的这段时间间隔
	- 周转时间，平均周转时间
		- $$周转时间 = 作业完成时间 - 作业提交时间$$
		- $$ 平均周转时间 = \frac{各作业周转时间之和}{作业数} $$
	- 带权周转时间，平均带权周转时间
		- $$ 带权周转时间 = \frac{作业周转时间}{作业实际运行时间} = \frac{作业完成时间 - 作业提交时间}{作业实际运行的时间} $$
		- $$平均带权周转时间 = \frac {各作业带权周转时间之和}{作业数}$$
- 等待时间
	- 对于进程来说,等待时间就是指进程建立后等待被服务的时间之和,在等待I/O完成的期间其实进程也是在被服务的,所以不计入等待时间。
	- 对于作业来说,不仅要考虑建立进程后的等待时间,还要加上作业在外存后备队列中等待的时间。
- 响应时间
	- 响应时间,指从用户提交请求到首次产生响应所用的时间。

## 调度算法

- **先来先服务(FCFS, First Come First Serve)**
	- 算法思想：主要从“公平”的角度考虑(类似于我们生活中排队买东西的例子)
	- 算法规则：按照作业/进程到达的先后顺序进行服务
	- 用于作业/进程调度：用于作业调度时,考虑的是哪个作业先到达后备队列;用于进程调度时,考虑的是哪个进程先到达就绪队列
	- 非抢占式的算法
	- 优缺点
		- 优点:公平、算法实现简单
		- 缺点:排在长作业(进程)后面的短作业需要等待很长时间,带权周转时间很大,对短作业来说用户体验不好。即,FCFS算法对长作业有利,对短作业不利(Eg:排队买奶茶 ... )
	- 是否导致饥饿：不会
	-  ![[Pasted image 20240620182126.png]]
- **短作业优先(SJF, Shortest Job First)**
	- 算法思想：追求最少的平均等待时间,最少的平均周转时间、最少的平均带权周转时间
	- 算法规则：最短的作业/进程优先得到服务(所谓“最短”,是指要求服务时间最短)
	- 用于作业/进程调度：即可用于作业调度,也可用于进程调度。用于进程调度时称为“短进程优先(SPF,Shortest Process First)算法”
	- SJF和SPF是非抢占式的算法。但是也有抢占式的版本 -- 最短剩余时间优先算法(SRTN,Shortest Remaining Time Next)
	- 优缺点
		- 优点:”最短的”平均等待时间、平均周转时间
		- 缺点:不公平。对短作业有利,对长作业不利。可能产生饥饿现象。另外,作业/进程的运行时间是由用户提供的,并不一定真实,不一定能做到真正的短作业优先
	- 是否导致饥饿：会。如果源源不断地有短作业/进程到来,可能使长作业/进程长时间得不到服务,产生“饥饿”现象。如果一直得不到服务,则称为“饿死”
	- 非抢占式短作业优先![[Pasted image 20240620183559.png]]
	-  抢占式短作业优先(最短剩余时间优先算法)![[Pasted image 20240620184707.png]]
- **高响应比优先算法(HRRN, Highest Response Ratio Next)**
	- 算法思想：要综合考虑作业/进程的等待时间和要求服务的时间
	- 算法规则：在每次调度时先计算各个作业/进程的响应比,选择响应比最高的作业/进程为其服务$$ 响应比 = \frac{等待时间 + 要求服务时间}{要求服务时间} $$
	- 用于作业/进程调度：即可用于作业调度,也可用于进程调度
	- 非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时,才需要调度,才需要计算响应比
	- 优缺点综合考虑了等待时间和运行时间(要求服务时间)等待时间相同时,要求服务时间短的优先(SJF的优点)要求服务时间相同时,等待时间长的优先(FCFS的优点)对于长作业来说,随着等待时间越来越久,其响应比也会越来越大,从而避免了长作业饥饿的问题
	- 是否导致饥饿：不会
	- ![[Pasted image 20240620190911.png]]
- ![[Pasted image 20240620191506.png]]

- **时间片轮转调度算法(RR)** 
	- 算法思想：公平地、轮流地为各个进程服务,让每个进程在一定时间间隔内都可以得到响应
	- 算法规则：按照各进程到达就绪队列的顺序,轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完,则剥夺处理机,将进程重新放到就绪队列队尾重新排队。
	- 用于作业/进程调度：用于进程调度(只有作业放入内存建立了相应的进程后,才能被分配处理机时间片)
	- 若进程未能在时间片内运行完,将被强行剥夺处理机使用权,因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到
	- 优缺点
		- 优点:公平;响应快,适用于分时操作系统;
		- 缺点:由于高频率的进程切换,因此有一定开销;不区分任务的紧急程度。
			- 如果时间片太大,使得每个进程都可以在一个时间片内就完成,则时间片轮转调度算法退化为先来先服务调度算法,并且会增大进程响应时间。因此时间片不能太大。
			- 另一方面,进程调度、切换是有时间代价的(保存、恢复运行环境),因此如果时间片太小,会导致进程切换过于频繁,系统会花大量的时间来处理进程切换,从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。
	- 是否导致饥饿：不会
	- 时间片为2![[Pasted image 20240620192723.png]]![[Pasted image 20240620192908.png]]![[Pasted image 20240620193055.png]]
	- 时间片为5![[Pasted image 20240620193249.png]]
- **优先级调度算法**
	- 算法思想：随着计算机的发展,特别是实时操作系统的出现,越来越多的应用场景需要根据任务的紧急程度来决定处理顺序
	- 算法规则：调度时选择优先级最高的作业/进程
	- 用于作业/进程调度：既可用于作业调度,也可用于进程调度。甚至,还会用于在之后会学习的I/O调度中
	- 抢占式、非抢占式都有。做题时的区别在于:非抢占式只需在进程主动放弃处理机时进行调度即可,而抢占式还需在就绪队列变化时,检查是否会发生抢占。
	- 优缺点
		- 优点:用优先级区分紧急程度、重要程度,适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。
		- 缺点:若源源不断地有高优先级进程到来,则可能导致饥饿
	- 是否导致饥饿：会。
	- 补充：
		- 就绪队列未必只有一个,可以按照不同优先级来组织。另外,也可以把优先级置位的头队近靠更在排程进的高
		- 根据优先级是否可以动态改变,可将优先级分为静态优先级和动态优先级两种。
			- 静态优先级:创建进程时确定,之后一直不变。
			- 动态优先级:创建进程时有一个初始值,之后会根据情况动态地调整优先级。
	- 非抢占式的优先级调度算法![[Pasted image 20240620194446.png]]
	- 抢占式的优先级调度算法![[Pasted image 20240620200753.png]]
- **多级反馈队列调度算法**
	- 算法思想：对其他调度算法的折中权衡
	- 算法规则：设置多级就绪队列,各级队列优先级从高到低,时间片从小到大
		- 新进程到达时先进入第1级队列,按FCFS原则排队等待被分配时间片,若用完时间片进程还未结束,则进程进入下一级队列队尾。如果此时已经是在最下级的队列,则重新放回该队列队尾
		- 只有第k级队列为空时,才会为k+1级队头的进程分配时间片
	- 用于作业/进程调度：用于进程调度
	- 抢占式的算法。在k级队列的进程运行过程中,若更上级的队列(1~k-1级)中进入了一个新进程,则由于新进程处于优先级更高的队列中,因此新进程会抢占处理机,原来运行的进程放回k级队列队尾。
	- 优缺点
		- 对各类型进程相对公平(FCFS的优点);每个新到达的进程都可以很快就得到响应(RR的优点);短进程只用较少的时间就可完成(SPF的优点);不必实现估计进程的运行时间(避免用户作假);可灵活地调整对各类进程的偏好程度,比如CPU密集型进程、I/O密集型进程(拓展:可以将因I/O而阻塞的进程重新放回原队列,这样I/O型进程就可以保持较高优先级)
	- 是否导致饥饿：会。
	- ![[Pasted image 20240620202134.png]]
	-  ![[Pasted image 20240620203019.png]]
## 进程同步，进程互斥

- 进程同步：同步亦称直接制约关系，它是指为完成某种任务而建立的两种或多个进程，哲学进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的制约关系就是源于它们之间的相互合作。
- 进程互斥：进程互斥指当一个进程访问果临界资源时,另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束,释放该资源之后,另一个进程才能去访问临界资源。
	- 四个部分
		- 临界区是进程中访问临界资源的代码段
		- 进入区和退出区是负责实现互斥多的代码
		- 临界区也可称为"临界段“
	```
	do{
		entry section; //进入区
		critical section; //临界区
		exit section; //退出区
		remainder section; //剩余区
	} while(true)
	```
	- 需要遵守的原则
		- 空闲等待 - 临界区空闲时，应允许一个进程访问
		- 忙则等待 - 临界区正在被访问时，其他试图访问的进程需要等待
		- 有限等待 - 要在有限时间内进入临界区，保证不会饥饿
		- 让权等待 - 进不了临界区的进程，要释放处理机，防止忙等

## 进程互斥的软件实现方式

- 单标志法
	- 算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程 进入临界区的权限只能被另一个进程赋予
	- 缺点：违反了”空闲让进“原则
	- ![[Pasted image 20240621181123.png]]
- 双标志先检查
	- 算法思想：设置一个布尔型数组flag[],数组中各个元素用来标记各进程想进入临界区的意愿,比如“flag[0]=ture”意味着0号进程PO现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区,如果没有,则把自身对应的标志flag[i]设为true,之后开始访问临界区。
	- 缺点：违反了"忙则等待”
	- ![[Pasted image 20240621181443.png]]
- 双标志后检查
	-  算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”,但是这两个操作又无法一气呵成,因此导致了两个进程同时进入临界区的问题。因此,人们又想到先“上锁”后“检查”的方法,来避免上述问题。
	- 缺点：双标志后检查法虽然解决了“忙则等待”的问题,但是又违背了“空闲让进”和“有限等待”
	 原则,会因各进程都长期无法访问临界资源而产生“饥饿”现象。
	- ![[Pasted image 20240621182042.png]]
- Peterson算法
	- 算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区,那可以让进程尝试“孔融让梨”(谦让)。做一个有礼貌的进程。
	- 不遵循"让权等待“原则，会发生”忙等"
	- ![[Pasted image 20240621182335.png]]
## 进程互斥的硬件实现方法

- 中断屏蔽方法
	- 利用“开/关中断指令”
	- 优点:简单、高效
	- 缺点:不适用于多处理机;只适用于操作系统内核进程,不适用于用户进程(因为开/关中断指令只能运行在内核态,这组指令如果能让用户随意使用会很危险)
- TestAndSet(Ts指令/TSL指令)
	- TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。
	- 若刚开始lock是false,则TSL返回的old值为false,while循环条件不满足,直接跳过循环,进入临界区。若刚开始 lock是true,则执行TLS后old返回的值为true,while循环条件满足,会一直循环,直到当前访问临界区的进程在退出区进行“解锁”。
	- 不满足让权等待原则
	- ![[Pasted image 20240621184841.png]]
- Swap指令(XCHG指令)
	- Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成
	- 不满足让权等待原则
	- ![[Pasted image 20240621185204.png]]
## 互斥锁

- 特性：
	- 需忙等,进程时间片用完才下处理机,违反“让权等待”
	- 优点:等待期间不用切换进程上下文,多处理器系统中,若上锁的时间短,则等待代价很低
	- 常用于多处理器系统,一个核忙等,其他核照常工作,并快速释放临界区
	- 不太适用于单处理机系统,忙等的过程中不可能解锁
	- ![[Pasted image 20240621185734.png]]
## 信号量机制

- 用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作,从而很方便的实现了进程互斥、进程同步。
- 信号量其实就是一个变量(可以是一个整数,也可以是更复杂的记录型变量),可以用一个信号量来表示系统中某种资源的数量,比如:系统中只有一台打印机,就可以设置一个初值为1的信号量。
- 整形信号量
	- 用一个整数型的变量作为信号量，用来表示系统中某种资源的数量
	- ![[Pasted image 20240621190735.png]]
- 记录型信号量
	- 整型信号量的缺陷是存在“忙等”问题,因此人们又提出了“记录型信号量”,即用记录型数据结构表示的信号量。
	- ![[Pasted image 20240621191508.png]]
## 用信号量实现进程互斥，同步，前驱关系

- 实现进程的互斥 
	- ![[Pasted image 20240621193008.png]]
- 实现进程同步
	- ![[Pasted image 20240621193344.png]]
- 实现进程的前驱关系
	- ![[Pasted image 20240621193647.png]]
## 生产者消费者问题

- 问题概述: 系统中有一组生产者进程和一组消费者进程,生产者进程每次生产一个产品放入缓冲区,消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)
- 生产者和消费者共享一个初始为空，大小为n的缓冲区
- 只有缓冲区没满时,生产者才能把产品放入缓冲区,否则必须等待。
- 只有缓冲区不空时,消费者才能从中取出产品,否则必须等待。
- 缓冲区是临界资源,各进程必须互斥地访问。
- ![[Pasted image 20240621195001.png]]

## 多生产者-多消费者问题

## 吸烟者问题

- 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中,第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料,供应者每次将两种材料放桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者进程一个信号告诉完成了,供 应者就会放另外两种材料再桌上,这个过程一直重复(让三个抽烟者轮流地抽烟)
- ![[Pasted image 20240622093733.png]]

## 读者-写者问题

- 有读者和写者两组并发进程,共享一个文件,当两个或两个以上的读进程同时访问共享数据时不会产生副作用,但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求:1允许多个读者可以同时对文件执行读操作;2只允许一个写者往文件中写信息;3任一写者在完成写操作之前不允许其他读者或写者工作;4写者执行写操作前,应让已有的读者和写者全部退出。
- ![[Pasted image 20240622095107.png]]
- 实现“读写公平”![[Pasted image 20240622095843.png]]

## 哲学家进餐问题

- 一张圆桌上坐着5名哲学家,每两个哲学家之间的桌上摆一根筷子,桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐,哲学家在思考时,并不影响他人。只有当哲学家饥饿时,才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上,则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐,当进餐完毕后,放下筷子继续思考。
- ![[Pasted image 20240622101044.png]]

## 管程

- 为什么要引入管程
	- 信号量存在的问题：编写程序困难，易出错
- 管程的定义和基本特征
	- 组成
		1. 局部于管程的共享数据结构说明
		2. 对该数据结构进行操作的一组过程
		3. 对局部于管程的共享数据设置初始值的语句
		4. 管程有一个名字
	- 管程的基本特征
		1. 局部于管程的数据只能被局部于管程的过程所访问
		2. 一个进程只有通过管程内的过程才能进入管程访问共享数据
		3. 每次仅允许一个进程在管程内执行某个内部过程
- 用管程解决生产者消费者的问题
	- ![[Pasted image 20240622103400.png]]
- Java中类似于管程的机制
	-  在Java中，如果用关键字synchronized来描述一个函数，那么这个函数同一时间内只能被一个线程调用
	- ![[Pasted image 20240622104232.png]]

## 死锁的概念

- 什么是死锁
	- 各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象
- 进程死锁，饥饿，死循环的区别
	- 饥饿
		- 由于长期得不到想要的资源,某进程无法向前推进的现象。比如:在短进程优先(SPF)算法中,若有源源不断的短进程到来,则长进程将一直得不到处理机,从而发生长进程“饥饿”。
	- 死循环
		- 某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的,有时是程序员故意设计的。
	- ![[Pasted image 20240622110316.png]]
- 死锁产生的必要条件
	1. 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。
	2. 不可剥夺条件：进程所获得的资源在未使用完之前，不能由其它进程强行夺走，只能主动释放
	3. 请求和保持条件:进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源又被其他进程占有,此时请求进程被阻塞,但又对自己已有的资源保持不放。
	4. 循环等待条件:存在一种进程资源的循环等待链,链中的每一个进程已获得的资源同时被下一个进程所请求。
- 什么时候会发生死锁
	- 对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁,对可剥夺的资源(CPU)的竞争是不会引起死锁的。
	- 进程推进顺序非法。请求和释放资源的顺序不当,也同样会导致死锁。例如,并发执行的进程P1、P2分别申请并占有了资源R1、R2,之后进程P1又紧接着申请资源R2,而进程P2又申请资源R1,两者会因为申请的资源被对方占有而阻塞,从而发生死锁。
	- 信号量的使用不当也会造成死锁。如生产者-消费者问题中,如果实现互斥的P操作在实现同步的P操作之前,就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)
- 死锁的处理策略
	1. 预防死锁。破坏死锁产生的四个必要条件中的一个或几个。
	2. 避免死锁。用某种方法防止系统进入不安全状态,从而避免死锁(银行家算法)
	3. 死锁的检测和解除。允许死锁的发生,不过操作系统会负责检测出死锁的发生,然后采取某措施解除死锁。

## 死锁的处理策略 -- 预防死锁

-  破坏互斥条件
	- 将临界资源改造为可共享使用的资源(如SPOOLing技术)
	- 缺点:可行性不高,很多时候无法破坏互斥条件
- 破坏不剥夺条件
	- 方案一,申请的资源得不到满足时,立即释放拥有的所有资源
	- 方案二,申请的资源被其他进程占用时,由操作系统协助剥夺(考虑优先级)
	- 缺点:实现复杂;剥夺资源可能导致部分工作失效;反复申请和释放导致系统开销大;可能导致饥饿
- 破坏请求和保持条件
	- 运行前分配好所有需要的资源,之后一直保持
	- 饿饥致导能可;低率用利源资:点缺
- 破坏循环等待条件
	- 给资源编号,必须按编号从小到大的顺序申请资源
	- 缺点:不方便增加新设备;会导致资源浪费;用户编程麻烦

## 死锁的处理策略 -- 避免死锁 

- 银行家算法
	- ![[Pasted image 20240622114441.png]]

## 死锁的处理策略 -- 检测和解除

- 死锁的检测
	- 用某种数据结构来保存资源的请求和分配信息;
	- 提供一种算法,利用上述信息来检测系统是否已进入死锁状态。
	- ![[Pasted image 20240622115726.png]]
- 死锁的解除
	- 资源剥夺法。挂起(暂时放到外存上)某些死锁进程,并抢占它的资源,将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
	- 撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁进程,并剥夺这些进程的资源。这种方式的优点是实现简单,但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间,已经接近结束了,一旦被终止可谓功亏一篑,以后还得从头再来。
	-  进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息,设置还原点。