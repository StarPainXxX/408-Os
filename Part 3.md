## 内存的基础知识

-    什么是内存，有何作用
	- 存储单元、内存地址 的概念和联系
	- 安字节编址 vs 按字编址
- 理原本基的行运程进
	- 指令的工作原理
		- 操作码+若干参数(可能包含地址参数)
	- 逻辑地址(相对地址) vs物理地址(绝对地址)
	- 从写程序到程序运行
		- 编辑源代码文件
		- 编译
			- 由源代码文件生成目标模块(高级语言“翻译”为机器语言)
		- 链接
			- 由目标模块生成装入模块,链接后形成完整的逻辑地址
		- 装入
			- 将装入模块装入内存,装入后形成物理地址
	- 三种链接方式
		- 静态链接
			- 装入前链接成一个完整装入模块
		- 装入时动态链接
			- 运行前边装入边链接
		- 运行时动态链接
			- 运行时需要目标模块才装入并链接
	- 三种装入方式
		- 绝对装入
			- 编译时产生绝对地址
		- 可重定位装入
			- 装入是将逻辑地址转化为物理地址
		- 动态运行时装入
			- 运行时将逻辑地址转化为物理地址，需设置重定位寄存器

## 内存管理的概念

- 内存空间的分配与回收
	- 连续分配管理方式
		- 单一连续分配
		- 固定分区分配
		- 动态分区分配
	- 非连续分配管理方式
		- 基本分页存储管理
		- 基本分段存储管理
		- 段页式存储管理
- 内存空间的扩充(实现虚拟性)
	- 覆盖技术
	- 交换技术
	- 虚拟存储技术
- 地址转换
	- 操作系统负责实现逻辑地址到物理地址的转换
	- 三种方式
		- 绝对装入:编译器负责地址转换(单道程序阶段,无操作系统)
		- 可重定位装入:装入程序负责地址转换(早期多道批处理阶段)
		- 动态运行时装入:运行时才进行地址转换(现代操作系统)
- 存储保护
	- 保证各进程在自己的内存空间内运行,不会越界访问
	- 两种方式
		- 设置上下限寄存器
		- 断判行进器存寄址地界、器存寄位定重用利

## 覆盖与交换

-   覆盖技术
	- 一个固定区
		- 存放最活跃的程序段
		- 固定区中的程序段在运行过程中不会调入调出
	- 若干覆盖区
		- 不可能同时被访问程序段可共享一个覆盖区
		- 覆盖区中的程序段在运行过程中会根据需要调入调出
	- 必须由程序员声明覆盖结构，操作系统完成自动覆盖
	- 缺点：对用户不透明，增加了用户编程负担
- 交换技术
	- 内存紧张时，换出某些进程以腾出内存空间，再换入某些进程
	- 磁盘分为文件区和对换区，换出的进程放在兑换区
- 覆盖与交换的区别
	- 覆盖是在同一个进程或程序中的
	- 交换是在不同进程(或作业)之间的

## 连续分配管理方式

- 单一连续分配
	- 在单一连续分配方式中,内存被分为系统区和用户区。系统区通常位于内存的低地址部分,用于存放操作系统相关数据;用户区用于存放用户进程相关数据。内存中只能有一道用户程序,用户程序独占整个用户区空间。
	- 优点：优点:实现简单;无外部碎片;可以采用覆盖技术扩充内存;不一定需要采取内存保护(eg:早期的PC操作系统MS-DOS)。
	- 缺点：只能用于单用户，单任务的操作系统中，有内部碎片，存储器利用率低
- 固定分区分配
	- 将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业
		- 分区大小相等
		- 分区大小不等
	- 操作系统需要建立一个数据结构 -- 分区说明表,来实现各个分区的分配与回收。每个表项对应一个分区,通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)。
	- 优点:实现简单,无外部碎片。
	- 缺点:a.当用户程序太大时,可能所有的分区都不能满足需求,此时不得不采用覆盖技术来解决,但这又会降低性能;b.会产生内部碎片,内存利用率低。
- 动态分区分配
	- 不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区
	- 使用数据结构记录
		- 空闲分区表
		- 空闲分区链
	- 分区分配
		-  动态分区分配算法
	- 分区分配和回收操作
		- 回收
			- 两个相邻空闲分区合并
	- 内部碎片,分配给某进程的内存区域中,如果有些部分没有用上。
	- 外部碎片,是指内存中的某些空闲分区由于太小而难以利用。
		- 采用紧凑技术 
## 动态分区分配算法

- 首次适应算法
	- 算法思想:每次都从低地址开始查找,找到第一个能满足大小的空闲分区。
	- 如何实现:空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表),找到大小能满足要求的第一个空闲分区。
- 最佳适应算法
	- 算法思想:由于动态分区分配是一种连续分配方式,为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间,可以尽可能多地留下大片的空闲区,即,优先使用更小的空闲区。
	- 如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表),找到大小能满足要求的第一个空闲分区。
	- 缺点:每次都选最小的分区进行分配,会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。
- 最坏适应算法
	- 算法思想:为了解决最佳适应算法的问题 -- 即留下太多难以利用的小碎片,可以在每次分配时优先使用最大的连续空闲区,这样分配后剩余的空闲区就不会太小,更方便使用。
	- 如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表),找到大小能满足要求的第一个空闲分区。
- 邻近适应算法
	- 算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区,而每次分配查找时,都要经过这些分区,因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索,就能解决上述问题。
	- 如何实现:空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表),找到大小能满足要求的第一个空闲分区。
## 基本分页存储管理的基本概念

-  概念
	- 将内存空间分为一个个大小相等的分区(比如:每个分区4KB),每个分区就是一个“页框”(页框=页帧=内存块=物理块=物理页面)。每个页框有一个编号,即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号),页框号从0开始。
	- 将进程的逻辑地址空间也分为与页框大小相等的一个个部分,每个部分称为一个“页”或“页面”。每个页面也有一个编号,即“页号”,页号也是从0开始。
- 页表 
	- 一个进程对应一张页表
	-  进程的每个页面对应一个页表项
	-  每个页表项由“页号”和“块号”组成
	-  页表记录进程页面和实际存放的内存块之间的映射关系
	- ![[Pasted image 20240623155744.png]]
- 如何实现地址转化
	- 特点:虽然进程的各个页面是离散存放的,但是页面内部是连续存放的
	- 如果要访问逻辑地址A,则
		1. 确定逻辑地址A对应的“页号”P
			- $$页号=\frac{逻辑地址}{页面长度}$$
		2. 找到P号页面在内存中的起始地址(需要查页表)
		3. 确定逻辑地址A的“页内偏移量”W
			- $$页内偏移量={逻辑地址}\%{页面长度}$$
	- 逻辑地址A对应的物理地址=P号页面在内存中的起始地址+页内偏移量W
	- 总结:页面大小刚好是2的整数幂有什么好处?
		1. 逻辑地址的拆分更加迅速 -- 如果每个页面大小为2KB,用二进制数表示逻辑地址,则末尾K位即为页内偏移量,其余部分就是页号。因此,如果让每个页面的大小为2的整数幂,计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量,而无需进行除法运算,从而提升了运行速度。
		2. 物理地址的计算更加迅速 -- 根据逻辑地址得到页号,根据页号查询页表从而找到页面存放的内存块号,将二进制表示的内存块号和页内偏移量拼接起来,就可以得到最终的物理地址。

## 基本地址变换机构

- 页表寄存器(PTR):存放页表在内存中的起始地址F和页表长度M
- 进程未执行时,页表的始址和页表长度放在进程控制块(PCB)中,当进程被调度时,操作系统内核会把它们放到页表寄存器中。
- ![[Pasted image 20240623162412.png]]

## 具有块表的地址变换机构

- 快表 ：快表,又称联想寄存器(TLB,translation lookaside buffer),是一种访问速度比内存快很多的高速缓存(TLB不是内存!),用来存放最近访问的页表项的副本,可以加速地址变换的速度。与此对应,内存中的表常称为慢表。
- ![[Pasted image 20240623172849.png]]
- 时间局部性:如果执行了程序中的某条指令,那么不久后这条指令很有可能再次执行;如果某个数据被访问过,不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)
- 空间局部性:一旦程序访问了某个存储单元,在不久之后,其附近的 存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放)

## 两级页表

- 单级页表的问题 
	- 问题一:页表必须连续存放,因此当页表很大时,需要占用很多个连续的页框。
	- 问题二:没有必要让整个页表常驻内存,因为进程在一段时间内可能只需要访问某几个特定的页面。
- 两级页表
	- ![[Pasted image 20240623174634.png]]
	- ![[Pasted image 20240623174610.png]]

## 基本分段存储管理

- 分段 ：
	- 进程的地址空间：进程的地址空间:按照程序自身的逻辑关系划分为若干个段,每个段都有一个段名(在低级语言中,程序员使用段名来编程),每段从0开始编址
	- 内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻
- 段表 
	- 每个段对应一个段表项,其中记录了该段在内存中的起始位置(又称“基址”)和段的长度。
	- 各个段表项的长度是相同的。例如:某系统按字节寻址,采用分段存储管理,逻辑地址结构为(段号16位,段内地址16位),因此用16位即可表示最大段长。物理内存大小为4GB(可用32位表示整个物理内存地址空间)。因此,可以让每个段表项占16+32=48位,即6B。由于段表项长度相同,因此段号可以是隐含的,不占存储空间。若段表存放的起始地址为M,则K号段对应的段表项存放的地址为M+$K*6$
	-  ![[Pasted image 20240623192908.png]]
- 分段比分页更容易实现信息的共享和保护
- 地址变换
	1. 由逻辑地址得到段号、段内地址
	2. 段号与段表寄存器中的段长度比较,检查是否越界
	3. 由段表始址、段号找到对应段表项
	4. 根据段表中记录的段长,检查段内地址是否越界
	5. 由段表中的“基址+段内地址”得到最终的物理地址
	6. 访问目标单元
- 分段VS分页
	- 分页对用户不可见,分段对用户可见
	- 分页的地址空间是一维的,分段的地址空间是二维的
	- 分段更容易实现信息的共享和保护(纯代码/可重入代码可以共享)
	- 分页(单级页表)、分段访问一个逻辑地址都需要两次访存,分段存储中也可以引入快表机构

## 段页式管理方式

- 分页管理
	- 内存空间利用率高,不会产生外部碎片,只会有少量的页内碎片
	- 不方便按照逻辑模块实现信息的共享和保护
- 分段管理
	- 很方便按照逻辑模块实 现信息的共享和保护
	- 如果段长过大,为其分配很大的连续空间会很不方便。另外,段式管理会产生外部碎片
- 段页式管理方式 
	- 分段+分页
		- 将地址空间按照程序自身的逻辑关系划分为若干个段,在将各段分为大小相等的页面
		- 将内存空间分为与页面大小相等的一个个内存块,系统以块为单位为进程分配内存
		- 逻辑地址结构:(段号,页号,页内偏移量)
	- 段表+页表
		- 每个段对应一个段表项。各段表项长度相同,由段号(隐含)、页表长度、页表存放地址 组成
		- 每个页对应一个页表项。各页表项长度相同,由页号(隐含)、页面存放的内存块号 组成
	- 地址变换
		1. 由逻辑地址得到段号、页号、页内偏移量
		2. 段号与段表寄存器中的段长度比较,检查是否越界
		3. 由段表始址、段号找到对应段表项
		4. 根据段表中记录的页表长度,检查页号是否越界
		5. 由段表中的页表地址、页号得到查询页表,找到相应页表项
		6. 由页面存放的内存块号、页内偏移量得到最终的物理地址
		7. 访问目标单元
	- ![[Pasted image 20240623194517.png]]
	- 每个段对应一个段表项,每个段表项由段号、页表长度、页表存放块号(页表起始地址)组成。每个段表项长度相等,段号是隐含的。
	- ![[Pasted image 20240623195159.png]]

## 虚拟内存的基本概念

- 传统存储管理的特征，缺点
	- 一次性:作业必须一次性全部装入内存后才能开始运行。这会造成两个问题:1.作业很大时,不能全部装入内存,导致大作业无法运行;2.当大量作业要求运行时,由于内存无法容纳所有作业,因此只有少量作业能运行,导致多道程序并发度下降。
	- 驻留性:一旦作业被装入内存,就会一直驻留在内存中,直至作业运行结束。事实上,在一个时段内,只需要访问作业的一小部分数据即可正常运行,这就导致了内存中会驻留大量的、暂时用不到的数据,浪费了宝贵的内存资源。
- 虚拟内存的定义和特征
	- 基于局部性原理,在程序装入时,可以将程序中很快会用到的部分装入内存,暂时用不到的部分留在外存,就可以让程序开始执行。
	- 在程序执行过程中,当所访问的信息不在内存时,由操作系统负责将所需信息从外存调入内存,然后继续执行程序。
	- 若内存空间不够,由操作系统负责将内存中暂时用不到的信息换出到外存。
	- 在操作系统的管理下,在用户看来似乎有一个比实际内存大得多的内存,这就是虚拟内存
	- 特性：
		- 多次性:无需在作业运行时一次性全部装入内存,而是允许被分成多次调入内存。
		- 对换性:在作业运行时无需一直常驻内存,而是允许在作业运行过程中,将作业换入、换出。
		- 虚拟性:从逻辑上扩充了内存的容量,使用户看到的内存容量,远大于实际的容量。
- 虚拟内存的实现
	- 请求分页存储管理
	- 请求分段存储管理
	- 请求段页式存储管理

## 请求分页管理方式

- 页表机制
	- 在基本分页的基础上增加了几个表项
	- 状态位:表示页面是否已在内存中
	- 访问字段:记录最近被访问过几次,或记录上次访问的时间,供置换算法选择换出页面时参考
	- 修改位:表示页面调入内存后是否被修改过,只有修改过的页面才需在置换时写回外存
	- 外存地址:页面在外存中存放的位置
- 缺页中断机构
	- 找到页表项后检查页面是否已在内存,若没在内存,产生缺页中断
	- 缺页中断处理中,需要将目标页面调入内存,有必要时还要换出页面
	- 缺页中断属于内中断,属于内中断中的“故障”,即可能被系统修复的异常
	- 一条指令在执行过程中可能产生多次缺页中断
- 地址变换机构(重点关注与基本分页不同的地方)
	- 找到页表项是需要检查页面是否在内存中
	- 若页面不再内存中,需要请求调页
	- 若内存空间不够,还需换出页面
	- 页面调入内存后,需要修改相应页表项
- ![[Pasted image 20240623201824.png]]
- ![[Pasted image 20240623201945.png]]

## 页面置换算法

- 最佳置换算法(OPT)
	- 每次选择淘汰的页面将是以后永不使用,或者在最长时间内不再被访问的页面,这样可以保证最低的缺页率。
- 先进先出置换算法(FIFO)
	- 每次选择淘汰的页面是最早进入内存的页面
	- 缺点:Belady异常--当为进程分配的物理块数增大时，缺页次数不减反增的异常现象
- 最近最久未使用置换算法(LRU)
	- 每次淘汰的页面是最近最久未使用的页面实现方法:赋予每个页面对应的页表项中,用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时,选择现有页面中t值最大的,即最近最久未使用的页面。
- 时间置换算法(CLOCK)
	- 简单的CLOCK算法实现方法:为每个页面设置一个访问位,再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时,其访问位置为1。当需要淘汰一个页面时,只需检查页的访问位。如果是0,就选择该页换出;如果是1,则将它置为0,暂不换出,继续检查下一个页面,若第一轮扫描中所有页面都是1,则将这些页面的访问位依次置为0后,再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面,因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)
- 改进型的时钟置换算法
- ![[Pasted image 20240623205007.png]]

## 页面的分配策略，抖动，工作集

- ![[Pasted image 20240623210454.png]]

## 内存映射文件

- ![[Pasted image 20240623211204.png]]